import React, { useState, useEffect, useRef, useCallback } from 'react'
import styled from 'styled-components'
import { useCellEditing } from '@shared/containers'
import { useSelectionCellsContext } from '../context/SelectionCellsContext'
import { theme } from '@ynput/ayon-react-components'
import { upperFirst } from 'lodash'

// Helper: generate system name
const generateSystemName = (displayName: string): string => {
  return displayName
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '')
}

const EditingContainer = styled.div`
  background: var(--md-sys-color-surface-container-lowest);
  border: 2px solid var(--md-sys-color-primary);
  padding: 8px;
  width: 350px;
  border-radius: 4px;
`

const InputLabel = styled.label`
  font-size: 12px;
  color: var(--md-sys-color-outline);
`

const StyledInput = styled.input`
  width: 100%;
  border: none;
  background-color: var(--md-sys-color-surface-container-lowest);
  color: var(--md-sys-color-on-surface);

  &:focus {
    outline: none;
  }

  &.system-name {
    ${theme.bodySmall}
  }
`

interface InlineEditingWidgetProps {
  cellId: string
  rowId: string
  entityType: string
  initialName: string
  initialLabel?: string
}

const EditingEntityWidget: React.FC<InlineEditingWidgetProps> = ({
  cellId,
  rowId,
  entityType,
  initialName,
  initialLabel = '',
}) => {
  const [label, setLabel] = useState(initialLabel)
  const [name, setName] = useState(initialName)
  const [isSaving, setIsSaving] = useState(false) // Add saving state
  const { setEditingCellId, updateEntities } = useCellEditing()
  const { focusCell, selectCell } = useSelectionCellsContext()
  const widgetRef = useRef<HTMLDivElement>(null)
  const labelInputRef = useRef<HTMLInputElement>(null)
  const nameInputRef = useRef<HTMLInputElement>(null)

  // Use refs to capture current values for click outside handler
  const currentValuesRef = useRef({ label, name, initialLabel, initialName })
  const handlersRef = useRef({
    handleSave: null as any,
    handleCancel: null as any,
    isSaving: false,
  })

  // Update the refs whenever values change
  useEffect(() => {
    currentValuesRef.current = { label, name, initialLabel, initialName }
    handlersRef.current.isSaving = isSaving
  }, [label, name, initialLabel, initialName, isSaving])

  const isNameAutoGenerated = name === generateSystemName(label)

  // Reset when props change
  useEffect(() => {
    setLabel(initialLabel)
    setName(initialName)
  }, [initialLabel, initialName])

  useEffect(() => {
    if (labelInputRef.current) {
      labelInputRef.current?.focus()
      // Position cursor at the end of the text
      const input = labelInputRef.current
      if (input) {
        const length = input.value.length
        input.setSelectionRange(length, length)
      }
    }
  }, [])

  const restoreFocus = useCallback(() => {
    // Restore focus to the table cell after closing
    const cellElement = document.getElementById(cellId)
    const td = cellElement?.closest('td') as HTMLElement | null
    if (td) {
      td.focus()
      // Also update the selection context
      selectCell(cellId, false, false)
      focusCell(cellId)
    }
  }, [cellId, selectCell, focusCell])

  const handleSave = useCallback(async () => {
    if (isSaving) return

    const hasChanges = name !== initialName || label !== initialLabel

    restoreFocus()
    setEditingCellId(null)

    if (hasChanges) {
      // optimistic update: set saving but donâ€™t block UI
      setIsSaving(true)

      const updates = []
      if (name !== initialName) {
        updates.push({
          field: 'name',
          value: name.trim() || generateSystemName(label.trim()),
          type: entityType,
          rowId,
          id: rowId,
        })
      }
      if (label !== initialLabel) {
        updates.push({
          field: 'label',
          value: label.trim(),
          type: entityType,
          rowId,
          id: rowId,
        })
      }

      try {
        // Optimistic: assume it will succeed
        await updateEntities(updates)
      } catch (error) {
        console.error('Failed to save entity changes:', error)
        // ðŸ”„ rollback if failed
        setLabel(initialLabel)
        setName(initialName)
        setEditingCellId(`${rowId}:label`)
      } finally {
        setIsSaving(false)
      }
    }
  }, [
    label,
    name,
    initialLabel,
    initialName,
    entityType,
    rowId,
    updateEntities,
    setEditingCellId,
    isSaving,
    restoreFocus,
  ])

  const handleCancel = useCallback(() => {
    if (isSaving) return // Don't allow cancel while saving
    restoreFocus()
    setEditingCellId(null)
  }, [setEditingCellId, isSaving, restoreFocus])

  // Update handlers ref so the stable event listeners can access current functions
  useEffect(() => {
    handlersRef.current.handleSave = handleSave
    handlersRef.current.handleCancel = handleCancel
  }, [handleSave, handleCancel])

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Prevent multiple saves if already saving
      if (handlersRef.current.isSaving) return

      if (event.key === 'Escape') {
        event.preventDefault()
        event.stopPropagation()
        handlersRef.current.handleCancel()
      } else if (event.key === 'Enter') {
        event.preventDefault()
        event.stopPropagation()
        handlersRef.current.handleSave()
      }
    }

    const handleClickOutside = async (event: Event) => {
      if (widgetRef.current && !widgetRef.current.contains(event.target as Node)) {
        // Get current values from refs
        const {
          label: currentLabel,
          name: currentName,
          initialLabel: currentInitialLabel,
          initialName: currentInitialName,
        } = currentValuesRef.current
        const hasChanges =
          currentName !== currentInitialName || currentLabel !== currentInitialLabel

        // Close widget first
        setEditingCellId(null)

        // Restore focus

        const cellElement = document.getElementById(cellId)
        const td = cellElement?.closest('td') as HTMLElement | null
        if (td) {
          td.focus()
          selectCell(cellId, false, false)
          focusCell(cellId)
        }

        // Save changes if any
        if (hasChanges) {
          try {
            const updates = []

            if (currentName !== currentInitialName) {
              updates.push({
                field: 'name',
                value: currentName.trim() || generateSystemName(currentLabel.trim()),
                type: entityType,
                rowId,
                id: rowId,
              })
            }

            if (currentLabel !== currentInitialLabel) {
              updates.push({
                field: 'label',
                value: currentLabel.trim(),
                type: entityType,
                rowId,
                id: rowId,
              })
            }

            if (updates.length > 0) {
              await updateEntities(updates)
            }
          } catch (error) {
            console.error('Failed to save entity changes:', error)
          }
        }
      }
    }
    document.addEventListener('keydown', handleKeyDown)
    document.addEventListener('click', handleClickOutside, true) // Use capture phase

    return () => {
      document.removeEventListener('keydown', handleKeyDown)
      document.removeEventListener('click', handleClickOutside, true)
    }
  }, [])

  const handleLabelChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      if (isSaving) return // Don't allow changes while saving
      const value = e.target.value
      setLabel(value)
      if (isNameAutoGenerated) {
        setName(generateSystemName(value))
      }
    },
    [isNameAutoGenerated, isSaving],
  )

  const handleNameChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      if (isSaving) return // Don't allow changes while saving
      setName(e.target.value)
    },
    [isSaving],
  )

  const handleInputKeyDown = useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'ArrowDown') {
      e.preventDefault()
      if (e.currentTarget === labelInputRef.current) {
        nameInputRef.current?.focus()
      }
    } else if (e.key === 'ArrowUp') {
      e.preventDefault()
      if (e.currentTarget === nameInputRef.current) {
        labelInputRef.current?.focus()
      }
    }
  }, [])

  const handleInputClick = useCallback((e: React.MouseEvent<HTMLInputElement>) => {
    e.stopPropagation()
  }, [])

  const handleInputDoubleClick = useCallback((e: React.MouseEvent<HTMLInputElement>) => {
    e.stopPropagation()
  }, [])

  const handleInputMouseDown = useCallback((e: React.MouseEvent<HTMLInputElement>) => {
    e.stopPropagation()
  }, [])

  const handleInputMouseUp = useCallback((e: React.MouseEvent<HTMLInputElement>) => {
    e.stopPropagation()
  }, [])

  return (
    <EditingContainer ref={widgetRef} onClick={(e) => e.stopPropagation()}>
      <StyledInput
        ref={labelInputRef}
        id={`${cellId}-label`}
        type="text"
        value={label}
        onChange={handleLabelChange}
        onKeyDown={handleInputKeyDown}
        onClick={handleInputClick}
        onDoubleClick={handleInputDoubleClick}
        onMouseDown={handleInputMouseDown}
        onMouseUp={handleInputMouseUp}
        placeholder={`${upperFirst(entityType)} label...`}
        style={{ paddingBottom: '6px' }}
        disabled={isSaving}
      />
      <InputLabel htmlFor={`${cellId}-name`}>Name</InputLabel>
      <StyledInput
        ref={nameInputRef}
        id={`${cellId}-name`}
        type="text"
        value={name}
        onChange={handleNameChange}
        onKeyDown={handleInputKeyDown}
        onClick={handleInputClick}
        onDoubleClick={handleInputDoubleClick}
        onMouseDown={handleInputMouseDown}
        onMouseUp={handleInputMouseUp}
        className="system-name"
        placeholder={`${entityType}_name`}
        disabled={isSaving}
      />
    </EditingContainer>
  )
}
export default EditingEntityWidget
