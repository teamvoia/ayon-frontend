import React, { useState, useEffect, useRef, useCallback } from 'react'
import styled from 'styled-components'
import { useCellEditing } from '@shared/containers'
import { useSelectionCellsContext } from '../context/SelectionCellsContext'
import { theme } from '@ynput/ayon-react-components'

// Helper: generate system name
const generateSystemName = (displayName: string): string => {
  return displayName
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '')
}

const EditingContainer = styled.div`
  background: var(--md-sys-color-surface-container-lowest);
  border: 2px solid var(--md-sys-color-primary);
  padding: 8px;
  width: 350px;
  border-radius: 4px;
`

const InputLabel = styled.label`
  font-size: 12px;
  color: var(--md-sys-color-outline);
`

const StyledInput = styled.input`
  width: 100%;
  border: none;
  background-color: var(--md-sys-color-surface-container-lowest);
  color: var(--md-sys-color-on-surface);

  &:focus {
    outline: none;
  }

  &.system-name {
    ${theme.bodySmall}
  }
`

interface InlineEditingWidgetProps {
  cellId: string
  rowId: string
  entityType: string
  initialName: string
  initialLabel?: string
}

const EditingEntityWidget: React.FC<InlineEditingWidgetProps> = ({
  cellId,
  rowId,
  entityType,
  initialName,
  initialLabel = '',
}) => {
  const [label, setLabel] = useState(initialLabel)
  const [name, setName] = useState(initialName)
  const [isSaving, setIsSaving] = useState(false) // Add saving state
  const { setEditingCellId, updateEntities } = useCellEditing()
  const { focusCell, selectCell } = useSelectionCellsContext()
  const widgetRef = useRef<HTMLDivElement>(null)
  const labelInputRef = useRef<HTMLInputElement>(null)
  const nameInputRef = useRef<HTMLInputElement>(null)

  const isNameAutoGenerated = name === generateSystemName(label)

  // Reset when props change
  useEffect(() => {
    setLabel(initialLabel)
    setName(initialName)
  }, [initialLabel, initialName])

  useEffect(() => {
    if (labelInputRef.current) {
      labelInputRef.current?.focus()
      // Position cursor at the end of the text
      const input = labelInputRef.current
      if (input) {
        const length = input.value.length
        input.setSelectionRange(length, length)
      }
    }
  }, [])

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Prevent multiple saves if already saving
      if (isSaving) return

      if (event.key === 'Escape') {
        event.preventDefault()
        event.stopPropagation()
        handleCancel()
      } else if (event.key === 'Enter') {
        event.preventDefault()
        event.stopPropagation()
        handleSave()
      }
    }

    document.addEventListener('keydown', handleKeyDown)

    return () => {
      document.removeEventListener('keydown', handleKeyDown)
    }
  }, [label, name, isSaving])

  const handleSave = useCallback(async () => {
    if (isSaving) return

    const hasChanges = name !== initialName || label !== initialLabel

    setEditingCellId(null)

    // Restore focus to the table cell after closing
    const cellElement = document.getElementById(cellId)
    const td = cellElement?.closest('td') as HTMLElement | null
    if (td) {
      td.focus()
      // Also update the selection context
      selectCell(cellId, false, false)
      focusCell(cellId)
    }

    if (hasChanges) {
      setIsSaving(true)

      try {
        const updates = []

        if (name !== initialName) {
          updates.push({
            field: 'name',
            value: name.trim() || generateSystemName(label.trim()),
            type: entityType,
            rowId,
            id: rowId,
          })
        }

        if (label !== initialLabel) {
          updates.push({
            field: 'label',
            value: label.trim(),
            type: entityType,
            rowId,
            id: rowId,
          })
        }

        if (updates.length > 0) {
          await updateEntities(updates)
        }
      } catch (error) {
        console.error('Failed to save entity changes:', error)
        // Rollback: re-enter editing mode with original values
        setEditingCellId(`${rowId}:label`)
        setLabel(initialLabel)
        setName(initialName)
      } finally {
        setIsSaving(false)
      }
    }
  }, [
    label,
    name,
    initialLabel,
    initialName,
    entityType,
    rowId,
    updateEntities,
    setEditingCellId,
    isSaving,
    cellId,
    selectCell,
    focusCell,
  ])

  const handleCancel = useCallback(() => {
    if (isSaving) return // Don't allow cancel while saving
    setEditingCellId(null)

    // Restore focus to the table cell after closing
    const cellElement = document.getElementById(cellId)
    const td = cellElement?.closest('td') as HTMLElement | null
    if (td) {
      td.focus()
      // Also update the selection context
      selectCell(cellId, false, false)
      focusCell(cellId)
    }
  }, [setEditingCellId, isSaving, cellId, focusCell, selectCell])

  const handleLabelChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      if (isSaving) return // Don't allow changes while saving
      const value = e.target.value
      setLabel(value)
      if (isNameAutoGenerated) {
        setName(generateSystemName(value))
      }
    },
    [isNameAutoGenerated, isSaving],
  )

  const handleNameChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      if (isSaving) return // Don't allow changes while saving
      setName(e.target.value)
    },
    [isSaving],
  )

  const handleInputKeyDown = useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'ArrowDown') {
      e.preventDefault()
      if (e.currentTarget === labelInputRef.current) {
        nameInputRef.current?.focus()
      }
    } else if (e.key === 'ArrowUp') {
      e.preventDefault()
      if (e.currentTarget === nameInputRef.current) {
        labelInputRef.current?.focus()
      }
    }
  }, [])

  return (
    <EditingContainer ref={widgetRef} onClick={(e) => e.stopPropagation()}>
      <StyledInput
        ref={labelInputRef}
        id={`${cellId}-label`}
        type="text"
        value={label}
        onChange={handleLabelChange}
        onKeyDown={handleInputKeyDown}
        placeholder="Enter display name"
        style={{ paddingBottom: '6px' }}
        disabled={isSaving}
      />
      <InputLabel htmlFor={`${cellId}-name`}>Name</InputLabel>
      <StyledInput
        ref={nameInputRef}
        id={`${cellId}-name`}
        type="text"
        value={name}
        onChange={handleNameChange}
        onKeyDown={handleInputKeyDown}
        className="system-name"
        placeholder="system_name_with_underscores"
        disabled={isSaving}
      />
    </EditingContainer>
  )
}
export default EditingEntityWidget
